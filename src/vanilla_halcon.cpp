///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.1.1
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include <halconcpp/HalconCpp.h>
#  include <halconcpp/HDevThread.h>
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local control variables
  HTuple  hv_TISMount, hv_Status, hv_TISMountSM;
  HTuple  hv_ObjectModel3D, hv_ObjectModel3DOut, hv_ObjectModel3DThresholded;
  HTuple  hv_Pose, hv_Score, hv_plane_distances, hv_ObjectModel3DConnected;
  HTuple  hv_ObjectModel3DSelected, hv_ObjectModel3D_, hv_TISMountTrans;

  //Reconstruct the three-dimensional surface of a pile of pipe
  //joints by using a multi-view stereo setup with four similar
  //cameras and detect the position of each joint by using
  //surface-based 3D matching.
  //
  //
  //*****
  //Initializations:
  //*****

  //
  //Part 1: Create a surface model of the pipe fittings to be matched.
  //*****
  ReadObjectModel3d("/home/htp/phobos_ws/src/halcon_matcher/halconmatcher/test/reference_model.stl", "mm", HTuple(), HTuple(), 
      &hv_TISMount, &hv_Status);
  CreateSurfaceModel(hv_TISMount, 0.03, HTuple(), HTuple(), &hv_TISMountSM);
  //
  //set_system ('thread_num', 4)

  ReadObjectModel3d("/home/htp/phobos_ws/src/halcon_matcher/halconmatcher/test/test_scene.ply", "m", HTuple(), HTuple(), &hv_ObjectModel3D, 
      &hv_Status);

  //visualize_object_model_3d (WindowHandle, [ObjectModel3D,TISMount], [], [], [], [], [], [], [], PoseOut)

  FitPrimitivesObjectModel3d(hv_ObjectModel3D, "primitive_type", "plane", &hv_ObjectModel3DOut);

  DistanceObjectModel3d(hv_ObjectModel3D, hv_ObjectModel3DOut, HTuple(), 0.05, HTuple(), 
      HTuple());

  //select_points_object_model_3d (ObjectModel3D, 'point_coord_z', -0.45, -0.40, ObjectModel3DThresholded)
  //find_surface_model (TISMountSM, ObjectModel3D, 0.03, 0.2, 0, 'false', [], [], Pose, Score, SurfaceMatchingResultID1)



  GetObjectModel3dParams(hv_ObjectModel3D, "&distance", &hv_plane_distances);

  SelectPointsObjectModel3d(hv_ObjectModel3D, "&distance", 0.004, 0.010, &hv_ObjectModel3DThresholded);
  ConnectionObjectModel3d(hv_ObjectModel3DThresholded, "distance_3d", 0.01, &hv_ObjectModel3DConnected);

  SelectObjectModel3d(hv_ObjectModel3DConnected, "num_points", "and", 1000, 10000, 
      &hv_ObjectModel3DSelected);

  FindSurfaceModel(hv_TISMountSM, hv_ObjectModel3DSelected, 0.1, 0.8, 0, "true", 
      HTuple(), HTuple(), &hv_Pose, &hv_Score, &hv_ObjectModel3D_);


   std::cout << (float) hv_Score;
  //RigidTransObjectModel3d(hv_TISMount, hv_Pose, &hv_TISMountTrans);


  //get_surface_matching_result (SurfaceMatchingResultID1, Score, 0, ResultValue)


}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  action();

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


